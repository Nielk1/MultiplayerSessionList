<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Home Page - MultiplayerSessionList</title>
    <!--<link rel="stylesheet" href="/lib/bootstrap/dist/css/bootstrap.min.css" />-->
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" />

    <link href="/lib/font-awesome/css/font-awesome.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="/css/icomoon.css" />
    <!--<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">-->
    <!--<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/felipec.min.css">-->
    <!--<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/obsidian.min.css">-->
    <!--<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/stackoverflow-dark.min.css">-->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/vs2015.min.css">
</head>
<body>
    <style>
        .pre {
            white-space: pre;
        }

        .player_avatars {
            text-align: center;
        }

            .player_avatars a img {
                height: 100px;
            }

        /* ^^^^^ old ^^^^^ */

        .force-ellipsis {
            text-overflow: ellipsis;
            text-wrap: nowrap;
            overflow: hidden;
        }

        @media (max-width: 575.99px) {
            .border-start-xs-0 {
                border-left: 0 !important;
            }
        }

        .border-dotted {
            border-style: dotted !important;
        }

        .border-dashed {
            border-style: dashed !important;
        }

        .json-ref-box {
            border: rgba(var(--bs-link-color-rgb), var(--bs-link-opacity, 1)) solid 1px;
            text-decoration: none;
            border-radius: 5px;
            padding: 0.15em;
        }

        .selected-anchor {
            /*background: #ffe066;
            border-radius: 4px;
            transition: background 0.2s;*/
        }
    </style>

    <style id="extra_data_style">
        .extra_item {
            display: none !important;
        }
    </style>

    <div class="container-fluid pt-2 border-bottom mb-2" style="top: 0; position: sticky; z-index: 99999; background-color: var(--bs-body-bg);">
        <div class="dropdown float-start">
            <button id="dropdownMenuLink" class="btn btn-secondary dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false">
                Game
            </button>

            <ul id="dropdownMenuContainer" class="dropdown-menu"></ul>
        </div>
        <p class="d-inline-flex gap-1 float-end">
            <button id="btnExtra" type="button" data-bs-toggle="button" aria-pressed="false" class="btn btn-outline-primary">Extra</button>
            <button id="btnRefresh" disabled="disabled" type="button" class="btn btn-outline-primary">Refresh</button>
        </p>
        <div class="text-center">
            <h1 class="display-5">Game List Test</h1>
        </div>
    </div>

    <div class="container-fluid">
        <div class="accordion pb-2">
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse1" aria-expanded="false" aria-controls="collapse1">
                        Rendered DOM Elements (Sources)
                    </button>
                </h2>
                <div id="collapse1" class="accordion-collapse collapse show" data-bs-parent="#accordionExample">
                    <div class="accordion-body">
                        <div id="sourceList" class="row"></div>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse1a" aria-expanded="false" aria-controls="collapse1a">
                        Rendered DOM Elements (Lobbies)
                    </button>
                </h2>
                <div id="collapse1a" class="accordion-collapse collapse show" data-bs-parent="#accordionExample">
                    <div class="accordion-body">
                        <div id="lobbyList" class="row"></div>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse1b" aria-expanded="false" aria-controls="collapse1b">
                        Rendered DOM Elements (Sessions)
                    </button>
                </h2>
                <div id="collapse1b" class="accordion-collapse collapse show" data-bs-parent="#accordionExample">
                    <div class="accordion-body">
                        <div id="sessionList" class="row"></div>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapse2" aria-expanded="false" aria-controls="collapse2">
                        Raw LD-JSON
                    </button>
                </h2>
                <div id="collapse2" class="accordion-collapse collapse" data-bs-parent="#accordionExample">
                    <div class="accordion-body p-0">
                        <pre class="m-0"><code class="language-json small" id="codeRawJsonLines"></code></pre>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapse3" aria-expanded="true" aria-controls="collapse3">
                        Data References Processed
                    </button>
                </h2>
                <div id="collapse3" class="accordion-collapse collapse" data-bs-parent="#accordionExample">
                    <div class="accordion-body p-0">
                        <pre class="m-0"><code class="language-json small" id="codeRawJson"></code></pre>
                    </div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapse4" aria-expanded="true" aria-controls="collapse4">
                        Notes
                    </button>
                </h2>
                <div id="collapse4" class="accordion-collapse collapse" data-bs-parent="#accordionExample">
                    <div class="accordion-body p-2">
                        <pre class="m-0">session.level.rules.game_mode/game_type > session.level.map.game_mode/game_type > session.level.game_mode/game_type</pre>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <footer class="border-top footer text-muted">
        <div class="container-fluid">
            &copy; 2026 - MultiplayerSessionList
        </div>
    </footer>
    <!--<script src="/lib/jquery/dist/jquery.min.js"></script>-->
    <!--<script src="/lib/bootstrap/dist/js/bootstrap.bundle.min.js"></script>-->
    <script src="//cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

    <!-- Utility Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/ansi_up@5.0.0/ansi_up.min.js"></script>

    <script type="module">
        import { RefreshSessionList } from '/js/gamelist.js';

        function ansiToHtml(text) {
            const ansi_up = new AnsiUp();
            return ansi_up.ansi_to_html(text);
        }

        function encodeAttr(text) {
            const elem = document.createElement('p');
            elem.setAttribute('title', text);
            const elemHtml = elem.outerHTML; // <p title="encodedText"> or maybe <p title='encodedText'>
            // Find out whether the browser used single or double quotes before encodedText
            const quote = elemHtml[elemHtml.search(/['"]/)];
            // Split up the generated HTML using the quote character; take item 1
            return elemHtml.split(new RegExp(quote))[1];
        }

        function escapeHtml(unsafe) {
            if (!unsafe)
                return unsafe;
            return unsafe
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        // Utility to get mode from query string
        function getStreamMode() {
            const params = new URLSearchParams(window.location.search);
            const mode = params.get('mode');
            if (mode === 'chunked') return 'chunked';
            return 'event'; // default
        }

        // Helper functions to replace jQuery .empty(), .addClass(), .removeClass(), .hasClass(), .data()
        function emptyElement(el) {
            while (el.firstChild) el.removeChild(el.firstChild);
        }
        function addClass(el, className) {
            el.classList.add(className);
        }
        function removeClass(el, className) {
            el.classList.remove(className);
        }
        function hasClass(el, className) {
            return el.classList.contains(className);
        }
        function setData(el, key, value) {
            el.dataset[key] = value;
        }
        function getData(el, key) {
            return el.dataset[key];
        }

        function isObject(item) {
            return (item && typeof item === 'object' && !Array.isArray(item));
        }

        //$(document).ready(function () {
        {
            var windowSearch = window.location.search;
            if (windowSearch.length > 0)
                windowSearch = '?' + windowSearch.substring(1);
            fetch('/api/2.0/games' + windowSearch)
                .then(response => response.json())
                .then(data => {
                    const dropdownMenuContainer = document.getElementById('dropdownMenuContainer');
                    emptyElement(dropdownMenuContainer);
                    for (var i = 0; i < data.length; i++) {
                        const dat = data[i];
                        const sessionRow = document.createElement('a');
                        sessionRow.className = 'dropdown-item';
                        sessionRow.href = '#';
                        sessionRow.textContent = dat.Name;
                        setData(sessionRow, 'value', dat.Key);

                        const li = document.createElement('li');
                        li.appendChild(sessionRow);
                        dropdownMenuContainer.appendChild(li);
                    }
                });
        }

        document.getElementById('dropdownMenuContainer').addEventListener('click', function (e) {
            if (e.target && e.target.classList.contains('dropdown-item')) {
                e.preventDefault();
                const item = e.target;
                if (hasClass(item, 'active')) {
                    removeClass(item, 'active');
                } else {
                    addClass(item, 'active');
                }
                const dropdownMenuContainer = document.getElementById('dropdownMenuContainer');
                const activeItems = dropdownMenuContainer.querySelectorAll('.dropdown-item.active');
                const btnRefresh = document.getElementById('btnRefresh');
                if (activeItems.length > 0) {
                    btnRefresh.removeAttribute("disabled");
                } else {
                    btnRefresh.setAttribute("disabled", "disabled");
                }
            }
        });

        function makeRefString(type, id) {
            function escapeRef(str) {
                return str.replace(/~/g, '~0').replace(/\//g, '~1');
            }
            return `#/${escapeRef(type)}/${escapeRef(id)}`;
        }

        function ReferenceNester(key, value, path) {
            if (path.length > 2) {
                if (isObject(value)) {
                    if (!!value.$type && !!value.$id) {
                        return { $ref: makeRefString(value.$type, value.$id) };
                    }
                }
            }
            return value;
        }
        function replacerWithPath(replacer) {
            let m = new Map();

            return function (field, value) {
                let path = m.get(this) + (Array.isArray(this) ? `[${field}]` : '\t' + field);
                if (value === Object(value)) m.set(value, path);
                return replacer.call(this, field, value, path.replace(/undefined\t\t?/, '').split('\t'))
            }
        }

        class FixedSizeBuffer {
            constructor(size) {
                this.size = size;
                this.buffer = [];
                return new Proxy(this, {
                    get(target, prop) {
                        if (!isNaN(prop)) {
                            return target.buffer[prop];
                        }
                        return target[prop];
                    },
                    set(target, prop, value) {
                        if (!isNaN(prop)) {
                            target.buffer[prop] = value;
                            return true;
                        }
                        target[prop] = value;
                        return true;
                    }
                });
            }

            push(item) {
                if (this.buffer.length >= this.size) {
                    this.buffer.shift(); // Remove the oldest item
                }
                this.buffer.push(item);
            }

            toArray() {
                return this.buffer.slice();
            }

            get length() {
                return this.buffer.length;
            }
        }

        function escapeIdForAnchor(str) {
            // Replace ~ with ~2, then / with ~1
            return str.replace(/~/g, '~2').replace(/\//g, '~1');
        }

        function wrapNodes(firstNode, lastNode, wrapperTag = 'span', attributes = {}) {
            // Step 1: Create the wrapper element
            const wrapper = document.createElement(wrapperTag);

            // loop attributes and add
            for (const [key, value] of Object.entries(attributes)) {
                wrapper.setAttribute(key, value);
            }

            // Step 2: Insert the wrapper before the first node
            firstNode.parentNode.insertBefore(wrapper, firstNode);

            // Step 3: Move all nodes from firstNode to lastNode (inclusive) into the wrapper
            let current = firstNode;
            let next;
            while (current) {
                next = current.nextSibling; // Save next sibling before moving
                wrapper.appendChild(current);
                if (current === lastNode) break;
                current = next;
            }
            return wrapper;
        }

        function linkifyRefs(codeElem) {
            // Find all text nodes containing $ref objects and replace with <a> elements
            // This is non-trivial: you must walk the DOM, find the right text, and replace only the $ref part
            // Example: Use a TreeWalker to find and replace
            const walker = document.createTreeWalker(codeElem, NodeFilter.SHOW_TEXT, null, false);
            let node;
            const refBuffer = new FixedSizeBuffer(5);
            const refBuffer2 = new FixedSizeBuffer(3);
            const quotedRegex = /^"(.+)"$/;
            let found_type = null;
            let found_id = null;
            let id_node = null;
            while ((node = walker.nextNode())) {
                if (node.nodeType === Node.TEXT_NODE && node.parentNode.nodeName !== "SPAN")
                    continue;
                refBuffer.push(node);
                refBuffer2.push(node);
                if (refBuffer.length == 5) {
                    if (refBuffer[0].nodeValue == '{' &&
                        refBuffer[1].nodeValue == '"$ref"' &&
                        refBuffer[2].nodeValue == ':' &&
                        refBuffer[4].nodeValue == '}') {

                        let match = quotedRegex.exec(refBuffer[3].nodeValue);
                        if (match !== null) {
                            //console.log(match);
                            let start = refBuffer[0];
                            let end = refBuffer[4];
                            if (start.nodeType === Node.TEXT_NODE && start.parentNode.nodeName == "SPAN")
                                start = start.parentNode;
                            if (end.nodeType === Node.TEXT_NODE && end.parentNode.nodeName == "SPAN")
                                end = end.parentNode;
                            const loc_id = `JSON_REFJUMP__${escapeIdForAnchor(match[1].replace(/^#+/, ''))}`;
                            //console.log('#' + loc_id);
                            wrapNodes(start, end, 'a', { 'href': `#${loc_id}`, 'class': 'json-ref-box' });
                        }
                    }
                }
                if (refBuffer2.length == 3) {
                    if (refBuffer2[0].nodeValue == '"$type"' &&
                        refBuffer2[1].nodeValue == ':') {

                        let match = quotedRegex.exec(refBuffer2[2].nodeValue);
                        if (match !== null) {
                            found_type = match[1];
                        }
                    }
                    if (refBuffer2[0].nodeValue == '"$id"' &&
                        refBuffer2[1].nodeValue == ':') {

                        let match = quotedRegex.exec(refBuffer2[2].nodeValue);
                        if (match !== null) {
                            found_id = match[1];
                            let start = refBuffer2[0];
                            if (start.nodeType === Node.TEXT_NODE && start.parentNode.nodeName == "SPAN")
                                start = start.parentNode;
                            id_node = start;
                        }
                    }
                    if (!!found_type && !!found_id) {
                        const anchor = document.createElement('a');
                        const loc_id = `JSON_REFJUMP__${escapeIdForAnchor(`/${escapeIdForAnchor(found_type)}/${escapeIdForAnchor(found_id)}`)}`;
                        //console.log(' ' + loc_id);
                        anchor.setAttribute('id', loc_id);
                        anchor.setAttribute('class', "");
                        anchor.setAttribute('style', "float:right;text-decoration:none;user-select:none;");
                        anchor.textContent = '<OBJECT';
                        id_node.parentNode.insertBefore(anchor, id_node);

                        found_id = null;
                        found_type = null;
                    }
                }
                //let match;
                //let replaced = false;
                //let text = node.nodeValue;
                //let newHtml = '';
                //let lastIndex = 0;
                //while ((match = refRegex.exec(text)) !== null) {
                //    replaced = true;
                //    newHtml += escapeHtml(text.slice(lastIndex, match.index));
                //    const ref = match[1];
                //    // Parse type/id from ref as needed
                //    newHtml += `<a href="#${ref.replace(/^#\//, '').replace(/\//g, '-')}">{ "$ref": "${ref}" }</a>`;
                //    lastIndex = refRegex.lastIndex;
                //}
                //if (replaced) {
                //    newHtml += escapeHtml(text.slice(lastIndex));
                //    const span = document.createElement('span');
                //    span.innerHTML = newHtml;
                //    node.parentNode.replaceChild(span, node);
                //}
            }
        }

        window.addEventListener('hashchange', function () {
            const header = document.querySelector('.container-fluid.pt-2.border-bottom.mb-2');
            const offset = header ? header.offsetHeight : 0;
            const id = location.hash.replace(/^#/, '');
            const anchor = document.getElementById(id);
            if (anchor) {
                // Scroll so anchor is just below the sticky header
                const rect = anchor.getBoundingClientRect();
                const scrollTop = window.pageYOffset + rect.top - offset - 8; // 8px for margin
                window.scrollTo({ top: scrollTop, behavior: 'smooth' });

                document.querySelectorAll('a.selected-anchor').forEach(function (el) {
                    el.classList.remove('selected-anchor');
                    el.classList.remove('json-ref-box');
                });

                anchor.classList.add('selected-anchor');
                anchor.classList.add('json-ref-box');
            }
        });

        document.getElementById('btnExtra').addEventListener('click', function (e) {
            e.preventDefault();
            const btnExtra = document.getElementById('btnExtra');
            const extraDataStyle = document.getElementById('extra_data_style');
            if (hasClass(btnExtra, 'active')) {
                extraDataStyle.sheet.cssRules[0].style.setProperty("display", "inherit");
            } else {
                extraDataStyle.sheet.cssRules[0].style.setProperty("display", "none", "important");
            }
        });
        document.getElementById('btnRefresh').addEventListener('click', function (e) {
            e.preventDefault();

            emptyElement(document.getElementById('sourceList'));
            emptyElement(document.getElementById('lobbyList'));
            emptyElement(document.getElementById('sessionList'));
            emptyElement(document.getElementById('codeRawJson'));
            emptyElement(document.getElementById('codeRawJsonLines'));

            // get all active dropdown items
            const dropdownMenuContainer = document.getElementById('dropdownMenuContainer');
            const activeItems = dropdownMenuContainer.querySelectorAll('.dropdown-item.active');
            const games = Array.from(activeItems).map(elem => getData(elem, 'value'));

            //btnRefresh.classList.add('loading');
            let GetGamesAjax = RefreshSessionList({
                updated: function (data, modified) {
                    let codeElem = document.getElementById('codeRawJson');
                    //codeElem.textContent = JSON.stringify(data, ReferenceNester, 2);
                    codeElem.textContent = JSON.stringify(data, replacerWithPath(ReferenceNester), 2).replace(/\{[ \r\n]*"\$ref"[ \r\n]*:[ \r\n]*("[^"]*")[ \r\n]*\}/g, '{ "$ref": $1 }');
                    delete codeElem.dataset.highlighted
                    hljs.highlightElement(codeElem);
                    linkifyRefs(codeElem);
                },
                raw: function (s) {
                    let codeElem2 = document.getElementById('codeRawJsonLines');
                    codeElem2.appendChild(document.createTextNode(s));
                    delete codeElem2.dataset.highlighted
                    hljs.configure({ ignoreUnescapedHTML: true }); // hljs misunderstands the multiple text-node children of the codeRawJsonLines element and thinks its HTML
                    hljs.highlightElement(codeElem2);
                },
                process: UpdateDatumDom,
                done: () => {
                    //sessionList.classList.remove('loading');
                    //btnRefresh.classList.remove('loading');
                },
            }, games);
        });

        var sourceList = document.querySelector('#sourceList');
        var lobbyList = document.querySelector('#lobbyList');
        var sessionList = document.querySelector('#sessionList');

        function UpdateDatumDom(updates, data) {
            //console.log(updates);
            const seen = new Set(); // prevent refiring updates we already did in this batch
            for (const [datumKey, affectedSet] of updates.entries()) {
                // type - Datum type that caused this update
                // id - Datum id that caused this update
                let [type, id] = datumKey.split('\t');

                for (const affected of affectedSet) {
                    // affectedType - Datum type that is influenced by this update
                    // affectedId - Datum id that is influenced by this update
                    let [affectedType, affectedId] = affected.split('\t');
                    const key = `${affectedType}\t${affectedId}`;
                    //console.log(`\t${affectedType}\t${affectedId}`);
                    if (seen.has(key)) continue;

                    if (affectedType === 'source') {
                        seen.add(key);
                    }
                    if (affectedType === 'session') {
                        if (type == 'source') { // TODO we can't see type at this point, need to refactor
                            // source nodes aren't refleccted in Session dom so ignore them even if they triggered an update
                        } else {
                            seen.add(key);
                        }
                    }
                    if (affectedType === 'lobby') {
                        if (type == 'source') {
                            // source nodes aren't refleccted in Session dom so ignore them even if they triggered an update
                        } else {
                            seen.add(key);
                        }
                    }
                }
            }
            for (const key of seen) {
                let [affectedType, affectedId] = key.split('\t');

                if (affectedType === 'source') {
                    CreateOrUpdateSourceDom(affectedId, data);
                }
                if (affectedType === 'session') {
                    CreateOrUpdateSessionDom(affectedId, data);
                }
                if (affectedType === 'lobby') {
                    CreateOrUpdateLobbyDom(affectedId, data);
                }
            }
        }

        function GenerateHtml_ModBoxes(mod) {
            let modBoxes = '';

            if (mod.dependencies) {
                for (let m of mod.dependencies) {
                    modBoxes += GenerateHtml_ModBox(m, false);
                }
            }

            return modBoxes;
        }

        // mapId is to allow the map to rewrite the sub-mods section, the modId of the base mod is also applied to allow this
        // mapId isn't actually a way updated can happen anymore so we can probably drop it
        function GenerateHtml_ModsRow(mod, mapId) {
            let htmlOut = ``;
            let modBoxes = GenerateHtml_ModBoxes(mod);

            if (mod) {
                htmlOut += `
<div class="col-12 col-sm-4 col-lg-3 col-xl-4 p-1 text-center">
            ${GenerateHtml_ModBox(mod, true)}
</div>
<div class="col-12 col-sm-8 col-lg-9 col-xl-8 border-0 border-start border-start-xs-0 small">
            <div class="row" data-path="mods" data-id-map="${encodeAttr(mapId)}" data-id-mod="${encodeAttr(mod.$id)}">${modBoxes}</div>
</div>`;
            } else {
                htmlOut += `
<div class="col-12 p-0 border-0 small" data-path="mods" data-id-map="${encodeAttr(mapId)}" data-id-mod="${encodeAttr(mod.$id)}">${modBoxes}</div>`;
            }
            return htmlOut
        }

        function GenerateHtml_ModBox(mod, primary) {
            return `
<div class="${primary ? '' : 'col-3 col-sm-2 col-lg-1 col-xl-2'} p-1">
            <div class="ratio ratio-1x1">
                <a class="ratio ratio-1x1" data-path="mod_box_link" ${mod.url ? `href="${encodeAttr(mod.url)}"` : ''} data-type="mod" data-id="${encodeAttr(mod.$id)}" target="_blank">
                    <img data-path="mod_box_image" data-type="mod" data-id="${encodeAttr(mod.$id)}" width="250" length="250" src="${encodeAttr(mod.image || '')}" title="${encodeAttr(mod.name || mod.$id)}" onerror="this.src='/img/no_steam_pfp.jpg'" class="img-thumbnail ${primary ? 'border-primary' : ''}" style="width:100%;height:auto;margin:auto;bottom:0;top:0;left:0;right:0;">
                </a>
            </div>
            ${primary ? `
            <div class="shadow-lg p-1 m-auto mb-1 mt-2 ${primary ? 'bg-primary bg-opacity-10 border border-primary text-primary' : 'bg-body-tertiary'} rounded text-truncate text-center">
                <small data-path="mod_box_name" data-type="mod" data-id="${encodeAttr(mod.$id)}" class="card-subtitle text-decoration-none" style="white-space:pre;">${mod.name || mod.$id}</small>
            </div>
            ` : ''}
</div>`;
        }

        function GenerateHtml_IdentitySteam(identity) {
            let platform_name = identity.nickname || identity.$id;
            let platform_profile = identity.profile_url;
            if (platform_profile) {
                return `<div class="force-ellipsis" data-id="${encodeAttr(identity.$id)}" data-type="${encodeAttr(identity.$type)}"><i class="icon icon-steam" aria-hidden="true" title="Steam"></i> <a href="${platform_profile}" title="${encodeAttr(platform_name)}" target="_blank" rel="noopener noreferrer">${escapeHtml(platform_name)}</a></div>`;
            } else {
                return `<div class="force-ellipsis" data-id="${encodeAttr(identity.$id)}" data-type="${encodeAttr(identity.$type)}"><i class="icon icon-steam" aria-hidden="true" title="Steam"></i> ${escapeHtml(platform_name)}</div>`;
            }
        }

        function GenerateHtml_IdentityGog(identity) {
            let platform_name = identity.username || identity.$id;
            let platform_profile = identity.profile_url;
            if (platform_profile) {
                return `<div class="force-ellipsis" data-id="${encodeAttr(identity.$id)}" data-type="${encodeAttr(identity.$type)}"><i class="icon icon-gog" aria-hidden="true" title="GOG"></i> <a href="${platform_profile}" title="${encodeAttr(platform_name)}" target="_blank" rel="noopener noreferrer">${escapeHtml(identity.username)}</a></div>`;
            } else {
                return `<div class="force-ellipsis" data-id="${encodeAttr(identity.$id)}" data-type="${encodeAttr(identity.$type)}"><i class="icon icon-gog" aria-hidden="true" title="GOG"></i> ${escapeHtml(platform_name)}</div>`;
            }
        }

        function GenerateHtml_MicroList(name, object, extra) {
            var htmlEntries = `
                        <div class="card border-secondary mt-2 small ${extra ? "extra_item" : ""}" style="--bs-border-opacity: .35; clear: both;">
            <div data-path="team_name" data-id-team="1"class="p-1 card-header d-flex justify-content-center">${name}</div>
            <ul class="list-group list-group-flush">`;
            for (let prop in object) {
                if (object[prop] === null) {

                } else if (typeof (object[prop]) == 'object') {
                    htmlEntries += `<li class="p-1 list-group-item force-ellipsis">${GenerateHtml_MicroList(`${name}/${prop}`, object[prop], false)}</li>`;
                } else {
                    htmlEntries += `<li class="p-1 list-group-item force-ellipsis" style="white-space:pre;">${prop}: ${object[prop]}</li>`;
                }
            }
            htmlEntries += `</ul></div>`;
            return htmlEntries;
        }

        function GenerateHtml_Player(player, is_leader, is_over_limit) {
            let plaform_avatar = '';
            let player_avatar_source = '';
            let player_avatar_id = '';
            for (let id in player.ids) {
                if (id == "steam") {
                    plaform_avatar = (player.ids[id].identity || {}).avatar_url || plaform_avatar;
                    player_avatar_id = player.ids[id].identity.$id;
                    player_avatar_source = id;
                    break;
                }
                if (id == "gog") {
                    plaform_avatar = (player.ids[id].identity || {}).avatar_url || plaform_avatar;
                    player_avatar_id = player.ids[id].identity.$id;
                    player_avatar_source = id;
                    break;
                }
            }

            let playerHtmlEntries = '';
            playerHtmlEntries += `
            <div data-path="player" data-type="player" data-id="${encodeAttr(player.$id ?? "")}" data-extra-leader="${is_leader ? true : false}" data-extra-overlimit="${is_over_limit ? true : false}" class="d-block border ${is_over_limit ? 'border-dashed' : ''} rounded h-100">
                `//<div class="col-3 m-2 d-block float-start h-100" style="max-width:100px;">
                + `<div class="col-3 m-2 d-block float-end" style="max-width:100px;">
                    <img data-path="avatar" data-source="${encodeAttr(player_avatar_source)}" data-id="${encodeAttr(player_avatar_id)}" src="${encodeAttr(plaform_avatar)}" width="150" height="150" onerror="this.src = '/img/no_steam_pfp.jpg'" class="img-fluid img-thumbnail rounded">
                </div>
                <div class=" m-2 d-block">
                    <div class="mb-1">
                        <div class="force-ellipsis">${escapeHtml(player.name)}</div>`;

            for (let id in player.ids) {
                switch (id) {
                    case "slot":
                        {
                            let platform_id = '' + player.ids[id].id;
                            playerHtmlEntries += `<div class="force-ellipsis"><i class="icon icon-hash" aria-hidden="true" title="Slot"></i> ${escapeHtml(platform_id)}</a></div>`;
                        }
                        break;
                    case "bzr_net":
                        {
                            let platform_id = '' + player.ids[id].id;
                            playerHtmlEntries += `<div class="force-ellipsis"><i class="fa fa-gamepad" aria-hidden="true" title="BZR-Net"></i> ${escapeHtml(platform_id)}</a></div>`;
                        }
                        break;
                    case "steam":
                        {
                            playerHtmlEntries += GenerateHtml_IdentitySteam(player.ids[id].identity);
                        }
                        break;
                    case "gog":
                        {
                            playerHtmlEntries += GenerateHtml_IdentityGog(player.ids[id].identity);
                        }
                        break;
                    default:
                        break;
                }
            }
            if (player.hero) {
                playerHtmlEntries += `<div class="force-ellipsis"><i class="fa fa-user-circle-o" aria-hidden="true" title="Hero"></i> <span data-path="hero_name" data-type="hero" data-id="${encodeAttr(player.hero.$id)}">${escapeHtml(player.hero.name || player.hero.$id)}</span></div>`;
            }
            playerHtmlEntries += `
                        <div>
                            ${player.type ? `<strong class="badge text-bg-secondary bg-opacity-75">${escapeHtml(player.type)}</strong>` : ''}
                            ${is_leader ? '<strong class="badge text-bg-light bg-opacity-75">Leader</strong>' : ''}
                            ${player.is_host ? '<strong class="badge text-bg-warning bg-opacity-75">Host</strong>' : ''}
                        </div>`;
            if (player.stats)
                playerHtmlEntries += GenerateHtml_MicroList("Stats", player.stats, true);
            if (player.other)
                playerHtmlEntries += GenerateHtml_MicroList("Other", player.other, true);
            playerHtmlEntries += `
                    </div>
                </div>
            </div>`;
            return playerHtmlEntries;
        }

        function CreateOrUpdateSourceDom($id, data) {
            var source = data.source[$id];
            var elementDom = sourceList.querySelector(`#\\/source\\/${CSS.escape($id)}`);

            if (!elementDom) {
                let dom_string = `
                <div id="/source/${encodeAttr($id)}" class="col-12 col-xl-6 mb-4">
                    <div class="card h-100 border-secondary" style="--bs-border-opacity: .35;">
                        <div class="card-header d-flex justify-content-between align-items-center">
                            <span class="force-ellipsis" style="white-space:pre;">${escapeHtml($id)}</span>
                        </div>
                        <ul class="list-group list-group-flush text-secondary">
                            <li class="list-group-item d-flex justify-content-between align-items-center">
                                <strong class="text-muted">Status</strong>
                                <span data-path="source.status" title=""></span>
                            </li>
                            <li class="list-group-item d-flex justify-content-between align-items-center">
                                <strong class="text-muted">Success</strong>
                                <span data-path="source.success" title=""></span>
                            </li>
                            <li class="list-group-item d-flex justify-content-between align-items-center">
                                <strong class="text-muted">TimeStamp</strong>
                                <span data-path="source.timestamp" title=""></span>
                            </li>
                            <li class="list-group-item d-flex justify-content-between align-items-center">
                                <strong class="text-muted">Name</strong>
                                <span data-path="source.name" title=""></span>
                            </li>
                        </ul>
                        <div class="container-fluid pb-1">
                            <div data-path="data-container" class="row" style="display:none;"></div>
                        </div>
                    </div>
                </div>`;
                sourceList.insertAdjacentHTML('beforeend', dom_string);
                elementDom = sourceList.lastElementChild;
            }

            if (source.other) {
                let modWrapperDom = elementDom.querySelector('[data-path="data-container"]');
                modWrapperDom.style.display = 'flex';
                modWrapperDom.innerHTML = '';

                if (source.other)
                    modWrapperDom.insertAdjacentHTML('beforeend', '<div class="mb-2">' + GenerateHtml_MicroList("root", source.other) + "</div>");
            }

            // Status
            let source_status_elem = elementDom.querySelector(`[data-path="source.status"]`);
            source_status_elem.textContent = source.status || "";
            if (!!source_status_elem.textContent) {
                source_status_elem.parentElement.style.removeProperty("display");
            } else {
                source_status_elem.parentElement.style.setProperty("display", "none", "important");
            }

            // Success
            let source_success_elem = elementDom.querySelector(`[data-path="source.success"]`);
            source_success_elem.textContent = source.success || "";
            if (!!source_success_elem.textContent) {
                source_success_elem.parentElement.style.removeProperty("display");
            } else {
                source_success_elem.parentElement.style.setProperty("display", "none", "important");
            }

            // Timestamp
            let source_timestamp_elem = elementDom.querySelector(`[data-path="source.timestamp"]`);
            source_timestamp_elem.textContent = source.timestamp || "";
            if (!!source_timestamp_elem.textContent) {
                source_timestamp_elem.parentElement.style.removeProperty("display");
            } else {
                source_timestamp_elem.parentElement.style.setProperty("display", "none", "important");
            }

            // Name
            let source_name_elem = elementDom.querySelector(`[data-path="source.name"]`);
            source_name_elem.textContent = source.name || "";
            if (!!source_name_elem.textContent) {
                source_name_elem.parentElement.style.removeProperty("display");
            } else {
                source_name_elem.parentElement.style.setProperty("display", "none", "important");
            }
        }
        function CreateOrUpdateSessionDom($id, data) {
            var session = data.session[$id];
            var elementDom = sessionList.querySelector(`#\\/session\\/${CSS.escape($id)}`);
            CreateOrUpdateSessionOrLobbyDom(sessionList, $id, session, elementDom, "session");
        }
        function CreateOrUpdateLobbyDom($id, data) {
            var session = data.lobby[$id];
            var elementDom = lobbyList.querySelector(`#\\/lobby\\/${CSS.escape($id)}`);
            CreateOrUpdateSessionOrLobbyDom(lobbyList, $id, session, elementDom, "lobby");
        }
        function CreateOrUpdateSessionOrLobbyDom(parent, $id, data, elementDom, type) {
            let forceRebuild = false;
            if (elementDom) {
                let mapImage_ExistingDom = !!elementDom.querySelector(`[data-path="${type}.level.map.image"]`);
                let mapImage_NewDom = !!data.level?.map?.image;

                let mapFile_ExistingDom = !!elementDom.querySelector(`[data-path="${type}.level.map.map_file"]`);
                let mapFile_NewDom = !!data.level?.map?.map_file;

                let Existing = mapImage_ExistingDom || mapFile_ExistingDom;
                let New = mapImage_NewDom || mapFile_NewDom;

                // if either of these values changed their nature, we will change the dom structure, so act like the structure is all new
                if (Existing != New) {
                    forceRebuild = true;
                }
            }

            if (!elementDom || forceRebuild) {
                let dom_string = `
<div id="/${type}/${encodeAttr($id)}" class="col-12 col-xl-6 mb-4">
            <div class="card h-100 border-secondary" style="--bs-border-opacity: .35;">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <span class="force-ellipsis" style="white-space:pre;">${escapeHtml($id)}</span>
                </div>
                <ul class="list-group list-group-flush">
                    <li data-path="${type}.message" class="list-group-item force-ellipsis" style="white-space:pre;"></li>
                </ul>
                <div class="container-fluid pb-1">
                    <div class="row border-bottom">`;
                if (!!data?.level?.map?.image || !!data?.level?.map?.map_file) {
                    dom_string += `
                        <div class="col-12 col-sm-4 col-lg-3 col-xl-4 p-1 text-center">
                            <div class="ratio ratio-1x1">
                                <img data-path="${type}.level.map.image" width="250" length="250" src onerror="this.src='/img/no_steam_pfp.jpg'" class="img-thumbnail" style="width:100%;height:auto;margin:auto;bottom:0;top:0;left:0;right:0;">
                            </div>
                            <div class="shadow-lg p-1 m-auto mb-1 mt-2 bg-body-tertiary rounded text-truncate">
                                <small data-path="${type}.level.map.map_file" class="card-subtitle text-body-secondary" style="white-space:pre;"></small>
                            </div>
                        </div>
                        <div class="col-12 col-sm-8 col-lg-9 col-xl-8 p-0 border-0 border-start border-start-xs-0 small">`;
                } else {
                    dom_string += `<div class="col-12 p-0 border-0 border-start border-start-xs-0 small">`;
                }
                dom_string += `
                            <ul class="list-group list-group-flush text-secondary">
                                <li class="list-group-item d-flex justify-content-between align-items-center">
                                    <strong class="text-muted">Type</strong>
                                    <span data-path="${type}.type" title=""></span>
                                </li>
                                <li class="list-group-item d-flex justify-content-between align-items-center">
                                    <strong class="text-muted">Map</strong>
                                    <span data-path="${type}.level.map.name" title=""></span>
                                </li>
                                <li class="list-group-item d-flex justify-content-between align-items-center">
                                    <strong class="text-muted">Type</strong>
                                    <span class="d-flex justify-content-between align-items-center">
                                        <img data-path="${type}.level.game_type.icon" class="me-1" src="/img/no_steam_pfp.jpg" width="20" height="20" onerror="this.src = '/img/no_steam_pfp.jpg'">
                                        <span data-path="${type}.level.game_type"></span>
                                    </span>
                                </li>
                                <li class="list-group-item d-flex justify-content-between align-items-center">
                                    <strong class="text-muted">Mode</strong>
                                    <span class="d-flex justify-content-between align-items-center">
                                        <img data-path="${type}.level.game_mode.icon" class="me-1" src="/img/no_steam_pfp.jpg" width="20" height="20" onerror="this.src = '/img/no_steam_pfp.jpg'">
                                        <span data-path="${type}.level.game_mode"></span>
                                    </span>
                                </li>
                                <li class="list-group-item d-flex justify-content-between align-items-center">
                                    <strong class="text-muted">Balance Paradigm</strong>
                                    <abbr data-path="${type}.level.game_balance"></abbr>
                                </li>
                                <li class="list-group-item d-flex justify-content-between align-items-center">
                                    <strong class="text-muted">State</strong>
                                    <span>
                                        <span data-path="${type}.status.is_locked"></span>
                                        <span data-path="${type}.status.has_password"></span>
                                        <span data-path="${type}.status.state"></span>
                                        <span data-path="${type}.time"></span>
                                    </span>
                                </li>
                                <li class="list-group-item d-flex justify-content-between align-items-center">
                                    <strong class="text-muted">Player Count</strong>
                                    <span data-path="${type}.player_count"></span>
                                </li>
                                <li class="list-group-item d-flex justify-content-between align-items-center">
                                    <strong class="text-muted">Game Version</strong>
                                    <span data-path="${type}.game.version"></span>
                                </li>
                                <li class="list-group-item d-flex justify-content-between align-items-center">
                                    <strong class="text-muted">Name</strong>
                                    <span data-path="${type}.name"></span>
                                </li>
                            </ul>
                        </div>
                    </div>
                    <div data-path="other-container" class="row border-bottom" style="display:none;"></div>
                    <div data-path="mods-container" class="row border-bottom" style="display:none;"></div>
                    <div data-path="players" class="row"></div>
                </div>
            </div>`;
                if (forceRebuild) {
                    elementDom.outerHTML = dom_string;
                } else {
                    parent.insertAdjacentHTML('beforeend', dom_string);
                    elementDom = parent.lastElementChild;
                }
            }

            // Session Type
            let session_type_elem = elementDom.querySelector(`[data-path="${type}.type"]`);
            session_type_elem.textContent = data.type || "";
            if (!!session_type_elem.textContent) {
                session_type_elem.parentElement.style.removeProperty("display");
            } else {
                session_type_elem.parentElement.style.setProperty("display", "none", "important");
            }

            // Map Image
            let map_image_elem = elementDom.querySelector(`[data-path="${type}.level.map.image"]`);
            if (map_image_elem)
                map_image_elem.setAttribute("src", data.level?.map?.image ?? "");

            // Map Filename
            let map_file_elem = elementDom.querySelector(`[data-path="${type}.level.map.map_file"]`);
            if (map_file_elem) {
                map_file_elem.textContent = data.level?.map?.map_file ?? " ";
                map_file_elem.setAttribute("title", data.level?.map?.map_file);
            }

            // Map Name
            let map_name_elem = elementDom.querySelector(`[data-path="${type}.level.map.name"]`);
            map_name_elem.setAttribute('title', data.level?.map?.map_file);
            map_name_elem.textContent = data.level?.map?.name ?? data.level?.map?.map_file ?? '';
            if (!!map_name_elem.textContent) {
                map_name_elem.parentElement.style.removeProperty("display");
            } else {
                map_name_elem.parentElement.style.setProperty("display", "none", "important");
            }

            // Game Version
            let game_version_elem = elementDom.querySelector(`[data-path="${type}.game.version"]`);
            game_version_elem.textContent = data.game?.version || "";
            if (!!game_version_elem.textContent) {
                game_version_elem.parentElement.style.removeProperty("display");
            } else {
                game_version_elem.parentElement.style.setProperty("display", "none", "important");
            }

            // Session Name
            let session_name_elem = elementDom.querySelector(`[data-path="${type}.name"]`);
            let session_name_ansi = data["name.ansi24b"] ?? data["name.ansi16p"];
            if (!!session_name_ansi) {
                session_name_elem.innerHTML = ansiToHtml(session_name_ansi);
            } else {
                session_name_elem.textContent = data.name || "";
            }
            if (!!session_name_elem.textContent) {
                session_name_elem.parentElement.style.removeProperty("display");
            } else {
                session_name_elem.parentElement.style.setProperty("display", "none", "important");
            }


            // Session Message
            let session_message_elem = elementDom.querySelector(`[data-path="${type}.message"]`);
            session_message_elem.textContent = data.message || "";
            if (!!session_message_elem.textContent) {
                session_message_elem.parentElement.style.removeProperty("display");
            } else {
                session_message_elem.parentElement.style.setProperty("display", "none", "important");
            }

            // Session Game Mode
            let game_mode_element = elementDom.querySelector(`[data-path="${type}.level.game_mode"]`);
            game_mode_element.textContent =
                data.level?.rules?.game_mode?.name ?? data.level?.rules?.game_mode?.$id ??
                data.level?.map?.game_mode?.name ?? data.level?.map?.game_mode?.$id ??
                data.level?.game_mode?.name ?? data.level?.game_mode?.$id;
            let game_mode_icon_element = elementDom.querySelector(`[data-path="${type}.level.game_mode.icon"]`);
            let game_mode_icon =
                data.level?.rules?.game_mode?.icon ??
                data.level?.map?.game_mode?.icon ??
                data.level?.game_mode?.icon;
            if (game_mode_icon) {
                game_mode_icon_element.setAttribute("src", game_mode_icon);
                game_mode_icon_element.style.display = null;
            } else {
                game_mode_icon_element.style.display = "none";
                game_mode_icon_element.setAttribute("src", "");
            }
            if (!!game_mode_element.textContent) {
                game_mode_element.parentElement.parentElement.style.removeProperty("display");
            } else {
                game_mode_element.parentElement.parentElement.style.setProperty("display", "none", "important");
            }

            // Session Game Type
            let game_type_element = elementDom.querySelector(`[data-path="${type}.level.game_type"]`);
            game_type_element.textContent =
                data.level?.rules?.game_type?.name ?? data.level?.rules?.game_type?.$id ??
                data.level?.map?.game_type?.name ?? data.level?.map?.game_type?.$id ??
                data.level?.game_type?.name ?? data.level?.game_type?.$id;
            let game_type_icon_element = elementDom.querySelector(`[data-path="${type}.level.game_type.icon"]`);
            let game_type_icon =
                data.level?.rules?.game_type?.icon ??
                data.level?.map?.game_type?.icon ??
                data.level?.game_type?.icon;
            if (game_type_icon) {
                game_type_icon_element.setAttribute("src", game_type_icon);
                game_type_icon_element.style.display = null;
            } else {
                game_type_icon_element.style.display = "none";
                game_type_icon_element.setAttribute("src", "");
            }
            if (!!game_type_element.textContent) {
                game_type_element.parentElement.parentElement.style.removeProperty("display");
            } else {
                game_type_element.parentElement.parentElement.style.setProperty("display", "none", "important");
            }

            // Session Game Balance
            let game_balance_element = elementDom.querySelector(`[data-path="${type}.level.game_balance"]`);
            let game_balance_data =
                data.level?.rules?.game_balance ??
                data.level?.map?.game_balance ??
                data.level?.game_balance ??
                data.game?.game_balance;

            if (game_balance_data) {
                game_balance_element.textContent = game_balance_data?.name ?? game_balance_data?.$id;
                if (game_balance_data.note) {
                    game_balance_element.setAttribute("title", game_balance_data.note);
                } else {
                    game_balance_element.removeAttribute("title");
                }
            } else {
                game_balance_element.textContent = '';
                game_balance_element.removeAttribute("title");
            }
            if (!!game_balance_element.textContent) {
                game_balance_element.parentElement.style.removeProperty("display");
            } else {
                game_balance_element.parentElement.style.setProperty("display", "none", "important");
            }



            // Session Time
            if (data.time) {
                let timeElem = elementDom.querySelector(`[data-path="${type}.time"]`);

                // minute resolutions
                if (data.time.resolution == 60) {
                    timeElem.textContent = `(${data.time.context ? `${data.time.context} for ` : ''}${data.time.seconds / 60}${data.time.max ? '+' : ''} minutes)`;
                } else {
                    timeElem.textContent = `(${data.time.context ? `${data.time.context} for ` : ''}${data.time.seconds}${data.time.max ? '+' : ''} seconds)`;
                }
            }

            // Session Status
            let timeElem = elementDom.querySelector(`[data-path="${type}.status.state"]`);
            let lockedElem = elementDom.querySelector(`[data-path="${type}.status.is_locked"]`);
            let passwordElem = elementDom.querySelector(`[data-path="${type}.status.has_password"]`);
            if (data.status?.state) {
                timeElem.textContent = data.status.state;
                lockedElem.textContent = data.status.is_locked ? "locked" : "";
                passwordElem.textContent = data.status.has_password ? "passworded" : "";

                timeElem.parentElement.parentElement.style.removeProperty("display");
            } else {
                timeElem.parentElement.parentElement.style.setProperty("display", "none", "important");
            }


            // Player Count Text
            if (data.player_types != null) {
                let player_count_string = '';
                for (var k = 0; k < data.player_types.length; k++) {
                    for (var L = 0; L < data.player_types[k].types.length; L++) {
                        var playerType = data.player_types[k].types[L];
                        if (L > 0)
                            player_count_string += ' ';
                        player_count_string += (data.player_count[playerType] + 0) + ' ' + playerType;
                    }
                    if (data.player_types[k].max) {
                        player_count_string += ` / ${data.player_types[k].max}`;
                    }
                }
                elementDom.querySelector(`[data-path="${type}.player_count"]`).textContent = player_count_string;
            }

            // Players
            {
                function microSort(a, b) {
                    if (a < b) return -1;
                    if (a > b) return 1;
                    return 0;
                }
                let Teams = new Set();
                if (data.players)
                    for (var i = 0; i < data.players.length; i++) {
                        if (data.players[i].team) {
                            Teams.add(data.players[i].team.id);
                        } else {
                            Teams.add(null);
                        }
                    }
                if (data.teams) {
                    for (var t in data.teams) {
                        Teams.add(t);
                    }
                }
                if (data.level?.map?.teams) {
                    for (var t in data.level.map.teams) {
                        Teams.add(t);
                    }
                }
                Teams = Array.from(Teams).sort();
                let team_balance = -1;
                let max_players = -1;
                let total_players = data.player_count?.player ?? -1;
                if (data.player_types) {
                    let team_count = Teams.filter(dr => dr != null && !(data.teams?.[dr]?.computer === true && !data.teams?.[dr]?.human)).length;
                    if (team_count > 1) {
                        let matchingTypes = data.player_types.filter(dr => dr.types.indexOf('player') >= 0);
                        if (matchingTypes.length > 0 && matchingTypes[0].max) {
                            max_players = matchingTypes[0].max;
                            team_balance = Math.floor(max_players / team_count);
                        }
                    }
                }
                let playerListDom = elementDom.querySelector('[data-path="players"]');
                playerListDom.innerHTML = '';
                if (data.players) {
                    let wrappedPlayers = data.players.map(p => {
                        let retVal = { player: p, team: null, leader: false };

                        if (!retVal.team && p.team) {
                            retVal.team = p.team.id;
                            retVal.leader = p.team.leader;
                        }

                        return retVal;
                    });
                    for (let team of Teams) {
                        let teamName = data.teams?.[team]?.name || data.level?.map?.teams?.[team]?.name || `Team ${team}`;
                        let teamPlayers = wrappedPlayers
                            .filter(p => p.team == team)
                            .sort((a, b) => {
                                let c = microSort(a.player?.team?.index ?? -1, b.player?.team?.index ?? -1);
                                if (c != 0) return c;
                                return microSort(a.player?.index ?? -1, b.player?.index ?? -1);
                            });

                        let playerHtmlEntries = '';

                        var player_count = teamPlayers.length;
                        if (data.teams?.[team])
                            if (max_players > -1 && total_players > -1 && data.teams[team].max) {
                                player_count = Math.max(Math.min(max_players - (total_players - teamPlayers.length), data.teams[team].max), teamPlayers.length);
                            } else {
                                player_count = Math.max(data.teams[team].max ?? player_count, teamPlayers.length, team_balance);
                            }
                        for (var i = 0; i < player_count; i++) {
                            if (i < teamPlayers.length) {
                                let player = teamPlayers[i];

                                let is_over_limit = data.teams?.[team]?.max && i > data.teams[team].max;
                                let is_leader = null;

                                if (team) {
                                    playerHtmlEntries += '<div class="col-12 p-0 pb-2">';
                                    is_leader = player.leader; // can't have a team leader without a team (I guess some games will be 1 team?)
                                } else {
                                    playerHtmlEntries += '<div class="col-12 col-md-6 p-0 p-2">';
                                }
                                playerHtmlEntries += GenerateHtml_Player(player.player, is_leader, is_over_limit);
                                playerHtmlEntries += '</div>';
                            } else {
                                let is_beyond_balance = team_balance >= 0 && i >= team_balance;

                                playerHtmlEntries += `
<div class="col-12 p-0 pb-2">
            <div class="d-block p-2 rounded border ${is_beyond_balance ? 'border-dashed opacity-50' : ''} text-secondary ps-3 text-bg-secondary bg-opacity-10 d-flex align-items-center h-100">
                <span class="text-nowrap overflow-hidden align-middle">
                    <i class="fa fa-user" aria-hidden="true"></i> Open
                </span>
            </div>
</div>`;
                            }
                        }
                        if (!data.teams?.[team]?.human && data.teams?.[team]?.computer === true) {
                            playerHtmlEntries += `
<div class="col-12 p-0 pb-2">
            <div class="d-block p-2 rounded border border-danger text-danger ps-3 text-bg-danger bg-opacity-10 d-flex align-items-center h-100">
                <span class="text-nowrap overflow-hidden align-middle">
                    <i class="fa fa-desktop" aria-hidden="true"></i> Computer
                </span>
            </div>
</div>`;
                        }

                        if (team) {
                            if (!data.teams?.[team]?.human && data.teams?.[team]?.computer === true) {
                                playerListDom.insertAdjacentHTML('beforeend', `
<div class="col-12 col-md-6 p-0 p-2">
            <div class="card h-100 border-danger" style="--bs-border-opacity: .35;">
                <div data-path="team_name" data-id-team="${encodeAttr(team)}" data-id-map="${data.level?.map?.$id ? encodeAttr(data.level.map.$id) : ''}" class="small card-header d-flex justify-content-center text-bg-danger">${escapeHtml(teamName)}</div>
                <div class="row m-2 mb-0">${playerHtmlEntries}</div>
            </div>
</div>`);
                            } else {
                                playerListDom.insertAdjacentHTML('beforeend', `
<div class="col-12 col-md-6 p-0 p-2">
            <div class="card h-100 border-secondary" style="--bs-border-opacity: .35;">
                <div data-path="team_name" data-id-team="${encodeAttr(team)}" data-id-map="${data.level?.map?.$id ? encodeAttr(data.level.map.$id) : ''}" class="small card-header d-flex justify-content-center">${escapeHtml(teamName)}</div>
                <div class="row m-2 mb-0">${playerHtmlEntries}</div>
            </div>
</div>`);
                            }
                        } else {
                            playerListDom.insertAdjacentHTML('beforeend', playerHtmlEntries);
                        }
                    }
                }
            }

            if (data.other || data.game?.other || data.level?.other || data.level?.rules) {
                let modWrapperDom = elementDom.querySelector('[data-path="other-container"]');
                modWrapperDom.style.display = 'flex';
                modWrapperDom.innerHTML = '';

                if (data.other)
                    modWrapperDom.insertAdjacentHTML('beforeend', '<div class="mb-2">' + GenerateHtml_MicroList("Other", data.other, true) + "</div>");

                if (data.game?.other)
                    modWrapperDom.insertAdjacentHTML('beforeend', '<div class="mb-2">' + GenerateHtml_MicroList("Game/Other", data.game.other, true) + "</div>");

                if (data.level?.other)
                    modWrapperDom.insertAdjacentHTML('beforeend', '<div class="mb-2">' + GenerateHtml_MicroList("Level/Other", data.level.other, true) + "</div>");

                if (data.level?.rules)
                    modWrapperDom.insertAdjacentHTML('beforeend', '<div class="mb-2">' + GenerateHtml_MicroList("Level/Rules", data.level.rules, true) + "</div>");

                if (data.level?.map?.other)
                    modWrapperDom.insertAdjacentHTML('beforeend', '<div class="mb-2">' + GenerateHtml_MicroList("Level/Map/Other", data.level.map.other, true) + "</div>");
            }

            {
                let modWrapperDom = elementDom.querySelector('[data-path="mods-container"]');
                modWrapperDom.style.display = 'flex';
                modWrapperDom.innerHTML = '';

                if ((data.game?.mods?.major?.length ?? 0) > 0) {
                    for (let modwrapper of data.game.mods.major) {
                        let newHTML = `<div class="col-12 p-0 p-2"><div class="card h-100 border-secondary" style="--bs-border-opacity: .35;">
                                    <div data-path="mod-container" data-id="${encodeAttr(modwrapper.mod.$id)}" class="small card-header d-flex justify-content-center">Major: ${modwrapper.role}</div>
                                    <div class="row m-0">${GenerateHtml_ModsRow(modwrapper.mod, data.level.map.$id)}</div>
                                </div></div>`;

                        // TODO remove the mod ID from these or move the logic back in here so we can do in-place updating instead of full dom rewrite
                        modWrapperDom.insertAdjacentHTML('beforeend', newHTML);
                    }
                }
                if ((data.game?.mods?.minor?.length ?? 0) > 0) {
                    for (let modwrapper of data.game.mods.minor) {
                        if (false) {
                            let newHTML = `<div class="col-12 col-sm-4 p-0 p-2"><div class="card h-100 border-secondary" style="--bs-border-opacity: .35;">
                                        <div data-path="mod-container" data-id="${encodeAttr(modwrapper.mod.$id)}" class="small card-header d-flex justify-content-center">Minor: ${modwrapper.role}</div>
                                        <div class="row m-0">${GenerateHtml_ModsRow(modwrapper.mod, data.level.map.$id)}</div>
                                    </div></div>`;

                            modWrapperDom.insertAdjacentHTML('beforeend', newHTML);
                        } else {
                            let newHTML = `<div class="col-6 col-sm-4 col-lg-3 col-xl-4 p-0 p-2"><div class="card h-100 border-secondary" style="--bs-border-opacity: .35;">
                                        <div data-path="mod-container" data-id="${encodeAttr(modwrapper.mod.$id)}" class="small card-header d-flex justify-content-center">Minor: ${modwrapper.role}</div>
                                        <div class="row m-0"><div class="col-12 p-1 text-center">${GenerateHtml_ModBox(modwrapper.mod, true)}</div></div>
                                    </div></div>`;

                            modWrapperDom.insertAdjacentHTML('beforeend', newHTML);
                        }
                    }
                }
                if ((data.game?.mods?.option?.length ?? 0) > 0) {
                    for (let modwrapper of data.game.mods.option) {
                        let newHTML = `<div class="col-12 p-0 p-2"><div class="card h-100 border-secondary" style="--bs-border-opacity: .35;">
                                    <div data-path="mod-container" data-id="${encodeAttr(modwrapper.mod.$id)}" class="small card-header d-flex justify-content-center">Option: ${modwrapper.role}</div>
                                    <div class="row m-0">${GenerateHtml_ModsRow(modwrapper.mod, data.level.map.$id)}</div>
                                </div></div>`;

                        // TODO remove the mod ID from these or move the logic back in here so we can do in-place updating instead of full dom rewrite
                        modWrapperDom.insertAdjacentHTML('beforeend', newHTML);
                    }
                }
            }
        }
    </script>
</body>
</html>
